
import numpy as np
import random
import cvxpy as cvx


def SimulateData(N_c, N_t, mu, sigma, l, u, eta):

	"""
	Function that generates random control and treated units.
	Each treated unit is generated by:
		X_t = w' X_c + epsilon,
	where
		X_c ~ N(mu, sigma^2), epsilon ~ N(0, eta^2)
	Args:
		N_c = Number of control units
		N_t = Number of treated units
		mu = Mean covariate value of control units
		sigma = Standard deviation of covariate value of control units
		l = Minimum number of non-zero weights on the control units
		u = Maximum number of non-zero weights on the control units
		eta = Standard deviation of normal, zero-mean error term
	Returns:
		X_c = Generated control units, 1D-array of size N_c
		X_t = Generated treated units, 1D-array of size N_t
		W = N_t-by-N_c matrix of weights put on control units
	"""

	X_c = np.random.normal(loc=mu, scale=sigma, size=N_c)  # covariates of controls
	X_t = np.zeros(N_t)  # covariates of treated units

	W = np.zeros(shape=(N_t, N_c))  # matrix of weights

	# number of non-zero weights for each X_t
	n = np.random.randint(low=l, high=u, size=N_t)

	for i in xrange(N_t):

		# controls that get non-zero weights
		random_index = random.sample(xrange(N_c), n[i])

		# generate weights, then standardize to sum to 1
		non_standardized = np.random.uniform(size=n[i])

		W[i, random_index] = non_standardized / non_standardized.sum()

	# generate X_t = w' * X_c + eta, where eta is N(0, eta^2)
	X_t = np.dot(W, X_c) + np.random.normal(scale=eta, size=N_t)

	return X_c, X_t, W


def EstimateWeights(X_c, X_t):

	"""
	Function that estimates synthetic control weights for each treated unit.
	For each treated unit, we find w that minimizes:
		|| w' X_c - X_t ||_2,
	subject to the weights being between 0 and 1, and that they sum to 1.
	Convex optimization problem solved by calling CVX.
	Args:
		X_c = 1D-array of control units
		X_t = 1D-array of treated units
	Returns:
		W_hat = 1D-array of estimated weights, same dimension as X_c
	"""

	N_c = len(X_c)
	N_t = len(X_t)
	W_hat = np.zeros(shape=(N_t, N_c))  # matrix of weight estimates

	for i in xrange(N_t):

		# for each treated unit, call CVX to solve optimization problem
		w = cvx.Variable(N_c)
		objective = cvx.Minimize(cvx.sum_squares(w.T*X_c - X_t[i]))
		constraints = [0 <= w, w <= 1, cvx.sum_entries(w) == 1]  # convex weights
		prob = cvx.Problem(objective, constraints)
		min_value = prob.solve()

		W_hat[i, ] = w.value.getA1()  # convert to flattened array and store

	return W_hat


def main():

	N_c, N_t = 5, 3  # set parameters
	mu, sigma, l, u, eta = 0, 1, 2, N_t, 1
	
	X_c, X_t, W = SimulateData(N_c, N_t, mu, sigma, l, u, eta)
	W_hat = EstimateWeights(X_c, X_t)

	print 'Actual weights:'
	print W
	print 'Estimated weights:'
	print W_hat

	# estimate weights using mean of X_t as the lone treated unit
	w = EstimateWeights(X_c, [X_t.mean()])

	print 'Averaged weights:'
	print W_hat.mean(axis=0)
	print 'Estimated weights using averaged X_t:'
	print w.flatten()


if __name__ == '__main__':
	main()
